mat
c(1, NULL)
sapply(1:5, function(i) c(LETTERS[i] = i))
sapply(1:5, function(i) list(LETTERS[i] = i))
sapply(1:5, function(i) c("A" = i))
sapply(1:5, function(i) c(as.character(i) = i))
n <- length(xx)
L_i <- numeric(n)
R_i <- numeric(n)
C_i <- rep(n - 1, n)
L <- c()
R <- c()
C <- seq(n)
C_inside <- C
k_i <- ceiling((n - 1) / 2)
interval <- c(-1e5, 1e5)
k_c <- ceiling(n / 2)
b <- 0.5
r <- ceiling(n^b)
####
# while(length(C) != 1) { # make for loop for test
# 1. sample dual lines w/ replacement
for (i in 1:10) {
cat(i, "\n")
r <- ceiling(n^b)
c_samp  <- sample(C_inside, r, replace = TRUE)
cat("y\n")
# 2. for each sampled line, calculate median intersection abscissa
# if (all(is.infinite(interval))) {
#   c_medians <- sapply(c_samp, function(x) {
#     abscissas <- sample(C, r, replace = FALSE)
#     slp <- (yy[x] - yy[abscissas]) / (xx[x] - xx[abscissas])
#     slp[which(rank(slp, ties.method = "first") == ceiling((sqrt(n) * k_i) / n))]
#   })
# } else {
intersect_lo <- interval[1] * xx - yy
intersect_hi <- interval[2] * xx - yy
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order <- order(intersect_lo_rank)
mat <- unique(matrix(get_inv_pairs(intersect_hi_rank[intersect_lo_order], c_samp), ncol = 2, byrow = TRUE))
c_medians <- sapply(c_samp, function(x) {
cat(x, "\n")
vec <- as.vector(mat[mat[, 1] == x | mat[, 2] == x, ])
vec <- vec[vec != x]
if (length(vector) == 0) {
return (NULL)
}
# if (length(vec) == 0)
samp <- sample(vec, r, replace = TRUE)
ints <- (yy[x] - yy[samp]) / (xx[x] - xx[samp])
ints[which(rank(ints, ties.method = "first") == ceiling((sqrt(n) * ceiling((n - 1) / 2)) / n))]
})
# }
cat("X\n")
# 3. compute new interval
k <- k_c - length(L)
C_len <- length(C_inside)
k_lo <- max(1, floor( (r * k) / C_len - (3 * sqrt(r)) / 2 ))
k_hi <- min(r, floor( (r * k) / C_len + (3 * sqrt(r)) / 2 ))
ranks <- rank(c_medians, ties.method = "first")
theta_lo_new  <- c_medians[ranks == k_lo]
theta_hi_new  <- c_medians[ranks == k_hi]
# 4. for each line inside C count the nr of intersections in the intervals
intersect_lo <- theta_lo_new * xx - yy
intersect_hi <- theta_hi_new * xx - yy
# C_i <- count_inversion_involvement(rank(intersect_hi)[rank(intersect_lo)])[rank(intersect_lo)]
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order<- order(intersect_lo_rank)
C_i <- count_inversion_involvement(intersect_hi_rank[intersect_lo_order])[order(intersect_lo_order)]
# if (all(is.infinite(interval))) {
# intersect_lo <- theta_hi_new * xx - yy
# intersect_hi <- 1e5 * xx - yy
intersect_hi <- theta_lo_new * xx - yy
intersect_lo <- -1e5 * xx - yy
# } else {
#   intersect_hi <- theta_lo_new * xx - yy
#   intersect_lo <- interval[1] * xx - yy
# }
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order<- order(intersect_lo_rank)
L_i <- count_inversion_involvement(intersect_hi_rank[intersect_lo_order])[order(intersect_lo_order)] # + L_i
R_i <- (n - 1 - C_i - L_i) # + R_i
if (sum(R_i >= k_c) >= k_c) {
# center is actually R_i
L_i <- C_i + L_i
C_i <- R_i
L   <- which(R_i < k_c)
R   <- c()
C_inside   <- which(R_i >= k_c)
R_i <- numeric(n)
interval <- c(theta_hi_new, if (is.infinite(interval[2])) 1e5 else interval[2])
} else if (sum(L_i >= k_c) >= k_c) {
# center is actually L_i
R_i <- C_i + R_i
C_i <- L_i
R   <- which(L_i < k_c)
L   <- c()
C_inside   <- which(L_i >= k_c)
L_i <- numeric(n)
interval <- c(if (is.infinite(interval[1])) -1e5 else interval[1], theta_lo_new)
} else {
L <- which(L_i >= k_c)
R <- which(R_i >= k_c)
C_inside <- setdiff(C, c(L, R))
interval <- c(theta_lo_new, theta_hi_new)
}
}
C_inside
interval
mblm(yy~xx)
mblm(yy~xx)
mblm::mblm(yy~xx)
mat
c_samp
c_samp  <- sample(C_inside, r, replace = TRUE)
cat("y\n")
# 2. for each sampled line, calculate median intersection abscissa
# if (all(is.infinite(interval))) {
#   c_medians <- sapply(c_samp, function(x) {
#     abscissas <- sample(C, r, replace = FALSE)
#     slp <- (yy[x] - yy[abscissas]) / (xx[x] - xx[abscissas])
#     slp[which(rank(slp, ties.method = "first") == ceiling((sqrt(n) * k_i) / n))]
#   })
# } else {
intersect_lo <- interval[1] * xx - yy
intersect_hi <- interval[2] * xx - yy
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order <- order(intersect_lo_rank)
mat <- unique(matrix(get_inv_pairs(intersect_hi_rank[intersect_lo_order], c_samp), ncol = 2, byrow = TRUE))
c_medians <- sapply(c_samp, function(x) {
cat(x, "\n")
vec <- as.vector(mat[mat[, 1] == x | mat[, 2] == x, ])
vec <- vec[vec != x]
if (length(vector) == 0) {
return (NULL)
}
# if (length(vec) == 0)
samp <- sample(vec, r, replace = TRUE)
ints <- (yy[x] - yy[samp]) / (xx[x] - xx[samp])
ints[which(rank(ints, ties.method = "first") == ceiling((sqrt(n) * ceiling((n - 1) / 2)) / n))]
})
n <- length(xx)
L_i <- numeric(n)
R_i <- numeric(n)
C_i <- rep(n - 1, n)
L <- c()
R <- c()
C <- seq(n)
C_inside <- C
k_i <- ceiling((n - 1) / 2)
k_c <- ceiling(n / 2)
interval <- c(-1e5, 1e5)
b <- 0.5
r <- ceiling(n^b)
####
# while(length(C) != 1) { # make for loop for test
# 1. sample dual lines w/ replacement
for (i in 1:10) {
cat(i, "\n")
r <- ceiling(n^b)
c_samp  <- sample(C_inside, r, replace = TRUE)
cat("y\n")
# 2. for each sampled line, calculate median intersection abscissa
# if (all(is.infinite(interval))) {
#   c_medians <- sapply(c_samp, function(x) {
#     abscissas <- sample(C, r, replace = FALSE)
#     slp <- (yy[x] - yy[abscissas]) / (xx[x] - xx[abscissas])
#     slp[which(rank(slp, ties.method = "first") == ceiling((sqrt(n) * k_i) / n))]
#   })
# } else {
intersect_lo <- interval[1] * xx - yy
intersect_hi <- interval[2] * xx - yy
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order <- order(intersect_lo_rank)
mat <- unique(matrix(get_inv_pairs(intersect_hi_rank[intersect_lo_order], c_samp), ncol = 2, byrow = TRUE))
c_medians <- sapply(c_samp, function(x) {
vec <- as.vector(mat[mat[, 1] == x | mat[, 2] == x, ])
vec <- vec[vec != x]
if (length(vector) == 0) {
return (NULL)
}
# if (length(vec) == 0)
samp <- sample(vec, r, replace = TRUE)
ints <- (yy[x] - yy[samp]) / (xx[x] - xx[samp])
ints[which(rank(ints, ties.method = "first") == ceiling((sqrt(n) * ceiling((n - 1) / 2)) / n))]
})
# }
cat("X\n")
# 3. compute new interval
k <- k_c - length(L)
C_len <- length(C_inside)
k_lo <- max(1, floor( (r * k) / C_len - (3 * sqrt(r)) / 2 ))
k_hi <- min(r, floor( (r * k) / C_len + (3 * sqrt(r)) / 2 ))
ranks <- rank(c_medians, ties.method = "first")
theta_lo_new  <- c_medians[ranks == k_lo]
theta_hi_new  <- c_medians[ranks == k_hi]
# 4. for each line inside C count the nr of intersections in the intervals
intersect_lo <- theta_lo_new * xx - yy
intersect_hi <- theta_hi_new * xx - yy
# C_i <- count_inversion_involvement(rank(intersect_hi)[rank(intersect_lo)])[rank(intersect_lo)]
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order<- order(intersect_lo_rank)
C_i <- count_inversion_involvement(intersect_hi_rank[intersect_lo_order])[order(intersect_lo_order)]
# if (all(is.infinite(interval))) {
# intersect_lo <- theta_hi_new * xx - yy
# intersect_hi <- 1e5 * xx - yy
intersect_hi <- theta_lo_new * xx - yy
intersect_lo <- -1e5 * xx - yy
# } else {
#   intersect_hi <- theta_lo_new * xx - yy
#   intersect_lo <- interval[1] * xx - yy
# }
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order<- order(intersect_lo_rank)
L_i <- count_inversion_involvement(intersect_hi_rank[intersect_lo_order])[order(intersect_lo_order)] # + L_i
R_i <- (n - 1 - C_i - L_i) # + R_i
if (sum(R_i >= k_c) >= k_c) {
# center is actually R_i
L_i <- C_i + L_i
C_i <- R_i
L   <- which(R_i < k_c)
R   <- c()
C_inside   <- which(R_i >= k_c)
R_i <- numeric(n)
interval <- c(theta_hi_new, if (is.infinite(interval[2])) 1e5 else interval[2])
} else if (sum(L_i >= k_c) >= k_c) {
# center is actually L_i
R_i <- C_i + R_i
C_i <- L_i
R   <- which(L_i < k_c)
L   <- c()
C_inside   <- which(L_i >= k_c)
L_i <- numeric(n)
interval <- c(if (is.infinite(interval[1])) -1e5 else interval[1], theta_lo_new)
} else {
L <- which(L_i >= k_c)
R <- which(R_i >= k_c)
C_inside <- setdiff(C, c(L, R))
interval <- c(theta_lo_new, theta_hi_new)
}
}
mat
c_medians <- sapply(c_samp, function(x) {
vec <- as.vector(mat[mat[, 1] == x | mat[, 2] == x, ])
vec <- vec[vec != x]
if (length(vector) == 0) {
return (NULL)
}
# if (length(vec) == 0)
samp <- sample(vec, r, replace = TRUE)
ints <- (yy[x] - yy[samp]) / (xx[x] - xx[samp])
ints[which(rank(ints, ties.method = "first") == ceiling((sqrt(n) * ceiling((n - 1) / 2)) / n))]
})
mat
c_samp
c_medians <- sapply(c_samp, function(x) {
vec <- as.vector(mat[mat[, 1] == x | mat[, 2] == x, ])
vec <- vec[vec != x]
if (length(vec) == 0) {
return (NULL)
}
# if (length(vec) == 0)
samp <- sample(vec, r, replace = TRUE)
ints <- (yy[x] - yy[samp]) / (xx[x] - xx[samp])
ints[which(rank(ints, ties.method = "first") == ceiling((sqrt(n) * ceiling((n - 1) / 2)) / n))]
})
n <- length(xx)
L_i <- numeric(n)
R_i <- numeric(n)
C_i <- rep(n - 1, n)
L <- c()
R <- c()
C <- seq(n)
C_inside <- C
k_i <- ceiling((n - 1) / 2)
k_c <- ceiling(n / 2)
interval <- c(-1e5, 1e5)
b <- 0.5
r <- ceiling(n^b)
####
# while(length(C) != 1) { # make for loop for test
# 1. sample dual lines w/ replacement
for (i in 1:10) {
cat(i, "\n")
r <- ceiling(n^b)
c_samp  <- sample(C_inside, r, replace = TRUE)
cat("y\n")
# 2. for each sampled line, calculate median intersection abscissa
# if (all(is.infinite(interval))) {
#   c_medians <- sapply(c_samp, function(x) {
#     abscissas <- sample(C, r, replace = FALSE)
#     slp <- (yy[x] - yy[abscissas]) / (xx[x] - xx[abscissas])
#     slp[which(rank(slp, ties.method = "first") == ceiling((sqrt(n) * k_i) / n))]
#   })
# } else {
intersect_lo <- interval[1] * xx - yy
intersect_hi <- interval[2] * xx - yy
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order <- order(intersect_lo_rank)
mat <- unique(matrix(get_inv_pairs(intersect_hi_rank[intersect_lo_order], c_samp), ncol = 2, byrow = TRUE))
c_medians <- sapply(c_samp, function(x) {
vec <- as.vector(mat[mat[, 1] == x | mat[, 2] == x, ])
vec <- vec[vec != x]
if (length(vec) == 0) {
return (NULL)
}
# if (length(vec) == 0)
samp <- sample(vec, r, replace = TRUE)
ints <- (yy[x] - yy[samp]) / (xx[x] - xx[samp])
ints[which(rank(ints, ties.method = "first") == ceiling((sqrt(n) * ceiling((n - 1) / 2)) / n))]
})
# }
cat("X\n")
# 3. compute new interval
k <- k_c - length(L)
C_len <- length(C_inside)
k_lo <- max(1, floor( (r * k) / C_len - (3 * sqrt(r)) / 2 ))
k_hi <- min(r, floor( (r * k) / C_len + (3 * sqrt(r)) / 2 ))
ranks <- rank(c_medians, ties.method = "first")
theta_lo_new  <- c_medians[ranks == k_lo]
theta_hi_new  <- c_medians[ranks == k_hi]
# 4. for each line inside C count the nr of intersections in the intervals
intersect_lo <- theta_lo_new * xx - yy
intersect_hi <- theta_hi_new * xx - yy
# C_i <- count_inversion_involvement(rank(intersect_hi)[rank(intersect_lo)])[rank(intersect_lo)]
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order<- order(intersect_lo_rank)
C_i <- count_inversion_involvement(intersect_hi_rank[intersect_lo_order])[order(intersect_lo_order)]
# if (all(is.infinite(interval))) {
# intersect_lo <- theta_hi_new * xx - yy
# intersect_hi <- 1e5 * xx - yy
intersect_hi <- theta_lo_new * xx - yy
intersect_lo <- -1e5 * xx - yy
# } else {
#   intersect_hi <- theta_lo_new * xx - yy
#   intersect_lo <- interval[1] * xx - yy
# }
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order<- order(intersect_lo_rank)
L_i <- count_inversion_involvement(intersect_hi_rank[intersect_lo_order])[order(intersect_lo_order)] # + L_i
R_i <- (n - 1 - C_i - L_i) # + R_i
if (sum(R_i >= k_c) >= k_c) {
# center is actually R_i
L_i <- C_i + L_i
C_i <- R_i
L   <- which(R_i < k_c)
R   <- c()
C_inside   <- which(R_i >= k_c)
R_i <- numeric(n)
interval <- c(theta_hi_new, if (is.infinite(interval[2])) 1e5 else interval[2])
} else if (sum(L_i >= k_c) >= k_c) {
# center is actually L_i
R_i <- C_i + R_i
C_i <- L_i
R   <- which(L_i < k_c)
L   <- c()
C_inside   <- which(L_i >= k_c)
L_i <- numeric(n)
interval <- c(if (is.infinite(interval[1])) -1e5 else interval[1], theta_lo_new)
} else {
L <- which(L_i >= k_c)
R <- which(R_i >= k_c)
C_inside <- setdiff(C, c(L, R))
interval <- c(theta_lo_new, theta_hi_new)
}
}
interval
n <- length(xx)
L_i <- numeric(n)
R_i <- numeric(n)
C_i <- rep(n - 1, n)
L <- c()
R <- c()
C <- seq(n)
C_inside <- C
k_i <- ceiling((n - 1) / 2)
k_c <- ceiling(n / 2)
interval <- c(-1e5, 1e5)
b <- 0.5
r <- ceiling(n^b)
####
# while(length(C) != 1) { # make for loop for test
# 1. sample dual lines w/ replacement
for (i in 1:50) {
cat(i, "\n")
r <- ceiling(n^b)
c_samp  <- sample(C_inside, r, replace = TRUE)
cat("y\n")
# 2. for each sampled line, calculate median intersection abscissa
# if (all(is.infinite(interval))) {
#   c_medians <- sapply(c_samp, function(x) {
#     abscissas <- sample(C, r, replace = FALSE)
#     slp <- (yy[x] - yy[abscissas]) / (xx[x] - xx[abscissas])
#     slp[which(rank(slp, ties.method = "first") == ceiling((sqrt(n) * k_i) / n))]
#   })
# } else {
intersect_lo <- interval[1] * xx - yy
intersect_hi <- interval[2] * xx - yy
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order <- order(intersect_lo_rank)
mat <- unique(matrix(get_inv_pairs(intersect_hi_rank[intersect_lo_order], c_samp), ncol = 2, byrow = TRUE))
c_medians <- sapply(c_samp, function(x) {
vec <- as.vector(mat[mat[, 1] == x | mat[, 2] == x, ])
vec <- vec[vec != x]
if (length(vec) == 0) {
return (NULL)
}
# if (length(vec) == 0)
samp <- sample(vec, r, replace = TRUE)
ints <- (yy[x] - yy[samp]) / (xx[x] - xx[samp])
ints[which(rank(ints, ties.method = "first") == ceiling((sqrt(n) * ceiling((n - 1) / 2)) / n))]
})
# }
cat("X\n")
# 3. compute new interval
k <- k_c - length(L)
C_len <- length(C_inside)
k_lo <- max(1, floor( (r * k) / C_len - (3 * sqrt(r)) / 2 ))
k_hi <- min(r, floor( (r * k) / C_len + (3 * sqrt(r)) / 2 ))
ranks <- rank(c_medians, ties.method = "first")
theta_lo_new  <- c_medians[ranks == k_lo]
theta_hi_new  <- c_medians[ranks == k_hi]
# 4. for each line inside C count the nr of intersections in the intervals
intersect_lo <- theta_lo_new * xx - yy
intersect_hi <- theta_hi_new * xx - yy
# C_i <- count_inversion_involvement(rank(intersect_hi)[rank(intersect_lo)])[rank(intersect_lo)]
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order<- order(intersect_lo_rank)
C_i <- count_inversion_involvement(intersect_hi_rank[intersect_lo_order])[order(intersect_lo_order)]
# if (all(is.infinite(interval))) {
# intersect_lo <- theta_hi_new * xx - yy
# intersect_hi <- 1e5 * xx - yy
intersect_hi <- theta_lo_new * xx - yy
intersect_lo <- -1e5 * xx - yy
# } else {
#   intersect_hi <- theta_lo_new * xx - yy
#   intersect_lo <- interval[1] * xx - yy
# }
intersect_lo_rank <- rank(intersect_lo, ties.method = "first")
intersect_hi_rank <- rank(intersect_hi, ties.method = "first")
intersect_lo_order<- order(intersect_lo_rank)
L_i <- count_inversion_involvement(intersect_hi_rank[intersect_lo_order])[order(intersect_lo_order)] # + L_i
R_i <- (n - 1 - C_i - L_i) # + R_i
if (sum(R_i >= k_c) >= k_c) {
# center is actually R_i
L_i <- C_i + L_i
C_i <- R_i
L   <- which(R_i < k_c)
R   <- c()
C_inside   <- which(R_i >= k_c)
R_i <- numeric(n)
interval <- c(theta_hi_new, if (is.infinite(interval[2])) 1e5 else interval[2])
} else if (sum(L_i >= k_c) >= k_c) {
# center is actually L_i
R_i <- C_i + R_i
C_i <- L_i
R   <- which(L_i < k_c)
L   <- c()
C_inside   <- which(L_i >= k_c)
L_i <- numeric(n)
interval <- c(if (is.infinite(interval[1])) -1e5 else interval[1], theta_lo_new)
} else {
L <- which(L_i >= k_c)
R <- which(R_i >= k_c)
C_inside <- setdiff(C, c(L, R))
interval <- c(theta_lo_new, theta_hi_new)
}
}
C_inside
interval
cor(xx, yy, method = "kendall")
get_dc_count(xx, yy)
get_dc_count(xx)
get_dc_count(xx[order(yy)])
get_dc_count(rank(xx)[order(rank(yy))]
get_dc_count(rank(xx)[order(rank(yy))])
(246-7)/(n*(n-1)/2)
?cor
xo <- xx
yo <- yy
xx
xo_rank <- rank(xo)
yo_rank <- rank(yo)
xo_rank <- rank(xo)
yo_rank <- rank(yo)
yo_rank[order(xo_rank)]
get_dc_count(yo_rank[order(xo_rank)])
yo_rank[order(xo_rank)] == xo_rank[order(xo_rank)]
sum(yo_rank[order(xo_rank)] == xo_rank[order(xo_rank)])
tie_sum <- sum(yo_rank[order(xo_rank)] == xo_rank[order(xo_rank)])
xo_rank <- rank(xo, ties.method = "first")
yo_rank <- rank(yo, ties.method = "first")
xo_rank
yo_rank
cor(xo_rank, yo_rank, method = "kendall")
get_dc_count(yo_rank[order(xo_rank)])
n
/
(246 - 7) / (n * (n - 1) / 2) -
(246 - 7) / (n * (n - 1) / 2)
